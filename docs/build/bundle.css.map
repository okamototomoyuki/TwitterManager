{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"typescript\">import { onMount } from \"svelte\";\r\nimport { xlink_attr } from \"svelte/internal\";\r\nimport Twitter from \"twitter-lite\";\r\nvar _STATE;\r\n(function (_STATE) {\r\n    _STATE[_STATE[\"NONE\"] = 0] = \"NONE\";\r\n    _STATE[_STATE[\"INIT\"] = 1] = \"INIT\";\r\n    _STATE[_STATE[\"REQUIRE\"] = 2] = \"REQUIRE\";\r\n    _STATE[_STATE[\"DONE\"] = 3] = \"DONE\";\r\n    _STATE[_STATE[\"ERROR\"] = 4] = \"ERROR\";\r\n})(_STATE || (_STATE = {}));\r\nlet state;\r\nlet error;\r\nlet text;\r\nlet consumerKey;\r\nlet consumerSecret;\r\nlet accessTokenKey;\r\nlet accessTokenSecret;\r\nlet threadId;\r\nlet client;\r\nlet tweets = [];\r\nlet filters = [];\r\nlet lastId;\r\n// 初期化時\r\nonMount(async () => {\r\n    const url = new URL(location.href);\r\n    const params = url.searchParams;\r\n    consumerKey = params.get(\"consumer_key\") ?? \"\";\r\n    consumerSecret = params.get(\"consumer_secret\") ?? \"\";\r\n    accessTokenKey = params.get(\"access_token_key\") ?? \"\";\r\n    accessTokenSecret = params.get(\"access_token_secret\") ?? \"\";\r\n    threadId = params.get(\"thread_id\") ?? \"\";\r\n    if (consumerKey.length == 0 ||\r\n        consumerSecret.length == 0 ||\r\n        accessTokenKey.length == 0 ||\r\n        accessTokenSecret.length == 0) {\r\n        state = _STATE.ERROR;\r\n        error =\r\n            \"consumer_key、consumer_secret、access_token_key または access_token_secretを URL で指定してください。\";\r\n        alert(error);\r\n        return;\r\n    }\r\n    // 記録情報で認証\r\n    client = new Twitter({\r\n        consumer_key: consumerKey,\r\n        consumer_secret: consumerSecret,\r\n        access_token_key: accessTokenKey,\r\n        access_token_secret: accessTokenSecret,\r\n    });\r\n    // Tweet 初期収集\r\n    let maxId = \"\";\r\n    while (true) {\r\n        const param = { count: 200 };\r\n        if (maxId !== \"\") {\r\n            param[\"max_id\"] = maxId;\r\n        }\r\n        const adds = await client.get(\"statuses/user_timeline\", param);\r\n        tweets = tweets.concat(adds);\r\n        if (adds.length < 200) {\r\n            break;\r\n        }\r\n        else {\r\n            maxId = tweets[tweets.length - 1].id_str;\r\n        }\r\n    }\r\n    // 追加収集関数作成\r\n    let prevId = 0;\r\n    let addTweet = async () => {\r\n        const param = { count: 1 };\r\n        const adds = await client.get(\"statuses/user_timeline\", param);\r\n        if (adds.length == 1) {\r\n            const id = parseInt(adds[0].id_str);\r\n            console.info(`${id}  ${prevId}`);\r\n            if (id > prevId) {\r\n                console.info(0);\r\n                prevId = id;\r\n                tweets = adds.concat(tweets);\r\n            }\r\n        }\r\n        console.info(1);\r\n        // スレッドが指定されたらそのスレッドの情報だけ取得\r\n        if (threadId.length > 0) {\r\n            filters = [];\r\n            const t = tweets.find((e) => e.id_str == threadId);\r\n            if (t != null) {\r\n                filters.push(t);\r\n                // 子を検索\r\n                let cs = tweets.filter((e) => t.id_str == e.in_reply_to_status_id_str);\r\n                while (cs.length > 0) {\r\n                    const c = cs.sort((a, b) => parseInt(a.id_str) - parseInt(b.id_str))[0];\r\n                    filters.unshift(c);\r\n                    cs = tweets.filter((e) => c.id_str == e.in_reply_to_status_id_str);\r\n                }\r\n                // 親を検索\r\n                let p = tweets.find((e) => t.in_reply_to_status_id_str == e.id_str);\r\n                while (p != null) {\r\n                    filters.push(p);\r\n                    p = tweets.find((e) => p.in_reply_to_status_id_str == e.id_str);\r\n                }\r\n                // コメントするときの親を取得\r\n                if (filters.length > 0) {\r\n                    lastId = filters[0].id_str;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            console.info(2);\r\n            filters = tweets;\r\n        }\r\n    };\r\n    document.addEventListener(\"keydown\", async function (e) {\r\n        if (e.code == \"Enter\" && e.ctrlKey) {\r\n            e.preventDefault();\r\n            const v = text.value;\r\n            text.value = \"\";\r\n            const param = {\r\n                status: v,\r\n                auto_populate_reply_metadata: true,\r\n            };\r\n            if (threadId !== \"\") {\r\n                param[\"in_reply_to_status_id\"] = lastId;\r\n            }\r\n            await client.post(\"statuses/update\", param);\r\n            addTweet();\r\n        }\r\n    });\r\n    text.focus();\r\n    addTweet();\r\n});\r\n// WebView2 活性時\r\nwindow[\"OnActive\"] = () => {\r\n    text.focus();\r\n};\r\n</script>\n\n<style lang=\"scss\">textarea {\n  width: 100%;\n  height: 100%;\n}\n\n.tweet {\n  border-style: solid;\n  border-bottom-width: 1px;\n  border-top-width: 0px;\n  border-left-width: 0px;\n  border-right-width: 0px;\n}</style>\n\n<main>\n  <textarea bind:this={text} />\n  {#each filters as tweet}\n    <div class=\"tweet\">\n      <div>\n        {#each tweet.text.split(/(\\n)/) as line}\n          <div>{line}</div>\n        {/each}\n      </div>\n      <div>\n        <a\n          href=\"?consumer_key={consumerKey}&consumer_secret={consumerSecret}&access_token_key={accessTokenKey}&access_token_secret={accessTokenSecret}&thread_id={tweet.id_str}\">\n          &#x25b6;\n        </a>\n      </div>\n    </div>\n  {/each}\n</main>\n"
  ],
  "names": [],
  "mappings": "AAuImB,QAAQ,eAAC,CAAC,AAC3B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACd,CAAC,AAED,MAAM,eAAC,CAAC,AACN,YAAY,CAAE,KAAK,CACnB,mBAAmB,CAAE,GAAG,CACxB,gBAAgB,CAAE,GAAG,CACrB,iBAAiB,CAAE,GAAG,CACtB,kBAAkB,CAAE,GAAG,AACzB,CAAC"
}