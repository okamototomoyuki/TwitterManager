{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"typescript\">import { onMount } from \"svelte\";\r\nimport { xlink_attr } from \"svelte/internal\";\r\nvar _STATE;\r\n(function (_STATE) {\r\n    _STATE[_STATE[\"NONE\"] = 0] = \"NONE\";\r\n    _STATE[_STATE[\"INIT\"] = 1] = \"INIT\";\r\n    _STATE[_STATE[\"REQUIRE\"] = 2] = \"REQUIRE\";\r\n    _STATE[_STATE[\"DONE\"] = 3] = \"DONE\";\r\n    _STATE[_STATE[\"ERROR\"] = 4] = \"ERROR\";\r\n})(_STATE || (_STATE = {}));\r\nclass KV {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\nclass Twitter {\r\n    constructor(apiKey, apiSecretKey, accessToken, accessTokenSecret) {\r\n        this._apiKey = apiKey;\r\n        this._apiSecretKey = apiSecretKey;\r\n        this._accessToken = accessToken;\r\n        this._accessTokenSecret = accessTokenSecret;\r\n    }\r\n    async get(url, params) {\r\n        const query = this._percentEncodeParams(params)\r\n            .map((pair) => pair.key + \"=\" + pair.value)\r\n            .join(\"&\");\r\n        const method = \"GET\";\r\n        // 認証情報\r\n        const authorizationHeader = await this._getAuthorizationHeader(method, url, params);\r\n        const headers = { Authorization: authorizationHeader };\r\n        // 通信\r\n        const response = await fetch(!params ? url : url + \"?\" + query, {\r\n            method,\r\n            headers,\r\n        });\r\n        return response.json();\r\n    }\r\n    async _getAuthorizationHeader(method, url, params) {\r\n        // パラメータ準備\r\n        const oauthParams = [\r\n            new KV(\"oauth_consumer_key\", this._apiKey),\r\n            new KV(\"oauth_nonce\", this._getNonce()),\r\n            new KV(\"oauth_signature_method\", \"HMAC-SHA1\"),\r\n            new KV(\"oauth_timestamp\", this._getTimestamp().toString()),\r\n            new KV(\"oauth_token\", this._accessToken),\r\n            new KV(\"oauth_version\", \"1.0\"),\r\n        ];\r\n        const allParams = this._percentEncodeParams([...oauthParams, ...params]);\r\n        this._ksort(allParams);\r\n        // シグネチャ作成\r\n        const signature = await this._getSignature(method, url, allParams);\r\n        // 認証情報\r\n        return (\"OAuth \" +\r\n            this._percentEncodeParams([\r\n                ...oauthParams,\r\n                new KV(\"oauth_signature\", signature),\r\n            ])\r\n                .map((pair) => pair.key + '=\"' + pair.value + '\"')\r\n                .join(\", \"));\r\n    }\r\n    async _getSignature(method, url, allParams) {\r\n        const allQuery = allParams\r\n            .map((pair) => pair.key + \"=\" + pair.value)\r\n            .join(\"&\");\r\n        // シグネチャベース・キー文字列\r\n        const signatureBaseString = [\r\n            method.toUpperCase(),\r\n            this._percentEncode(url),\r\n            this._percentEncode(allQuery),\r\n        ].join(\"&\");\r\n        const signatureKeyString = [this._apiSecretKey, this._accessTokenSecret]\r\n            .map((secret) => this._percentEncode(secret))\r\n            .join(\"&\");\r\n        // シグネチャベース・キー\r\n        const signatureBase = this._stringToUint8Array(signatureBaseString);\r\n        const signatureKey = this._stringToUint8Array(signatureKeyString);\r\n        // シグネチャ計算\r\n        const signatureCryptoKey = await window.crypto.subtle.importKey(\"raw\", signatureKey, { name: \"HMAC\", hash: { name: \"SHA-1\" } }, true, [\"sign\"]);\r\n        const signatureArrayBuffer = await window.crypto.subtle.sign(\"HMAC\", signatureCryptoKey, signatureBase);\r\n        return this._arrayBufferToBase64String(signatureArrayBuffer);\r\n    }\r\n    /**\r\n     * RFC3986 仕様の encodeURIComponent\r\n     */\r\n    _percentEncode(str) {\r\n        return encodeURIComponent(str).replace(/[!'()*]/g, (char) => \"%\" + char.charCodeAt(0).toString(16));\r\n    }\r\n    _percentEncodeParams(params) {\r\n        return params.map((pair) => {\r\n            const key = this._percentEncode(pair.key);\r\n            const value = this._percentEncode(pair.value);\r\n            return { key, value };\r\n        });\r\n    }\r\n    _ksort(params) {\r\n        return params.sort((a, b) => {\r\n            const keyA = a.key;\r\n            const keyB = b.key;\r\n            if (keyA < keyB)\r\n                return -1;\r\n            if (keyA > keyB)\r\n                return 1;\r\n            return 0;\r\n        });\r\n    }\r\n    _getNonce() {\r\n        const array = new Uint8Array(32);\r\n        window.crypto.getRandomValues(array);\r\n        // メモ: Uint8Array のままだと String に変換できないので、Array に変換してから map\r\n        return [...array]\r\n            .map((uint) => uint.toString(16).padStart(2, \"0\"))\r\n            .join(\"\");\r\n    }\r\n    _getTimestamp() {\r\n        return Math.floor(Date.now() / 1000);\r\n    }\r\n    _stringToUint8Array(str) {\r\n        return Uint8Array.from(Array.from(str).map((char) => char.charCodeAt(0)));\r\n    }\r\n    _arrayBufferToBase64String(arrayBuffer) {\r\n        const string = new Uint8Array(arrayBuffer)\r\n            .reduce((data, char) => {\r\n            data.push(String.fromCharCode(char));\r\n            return data;\r\n        }, [])\r\n            .join(\"\");\r\n        return btoa(string);\r\n    }\r\n}\r\nlet state;\r\nlet error;\r\nlet text;\r\n// 入力欄値更新時\r\nconst handleClick = (e) => {\r\n    const word = text.value;\r\n    if (\"chrome\" in window && \"webview\" in window[\"chrome\"]) {\r\n        // WebView2 から呼び出されてるならメッセージ\r\n        window[\"chrome\"].webview.postMessage(`google:${word}`);\r\n    }\r\n    else {\r\n        // ブラウザからなら通常の新しいウインドウ\r\n        window.open(`https://www.google.com/search?q=${word}`);\r\n    }\r\n    text.value = \"\";\r\n};\r\n// 初期化時\r\nonMount(async () => {\r\n    state = _STATE.INIT;\r\n    const url = new URL(location.href);\r\n    const params = url.searchParams;\r\n    const consumerKey = params.get(\"consumer_key\") ?? \"\";\r\n    const consumerSecret = params.get(\"consumer_secret\") ?? \"\";\r\n    const access_token_key = params.get(\"access_token_key\") ?? \"\";\r\n    const access_token_secret = params.get(\"access_token_secret\") ?? \"\";\r\n    if (consumerKey.length == 0 || consumerSecret.length == 0) {\r\n        state = _STATE.ERROR;\r\n        error =\r\n            \"consumer_key、consumer_secret、access_token_key または access_token_secretを URL で指定してください。\";\r\n        return;\r\n    }\r\n    // 記録情報で認証\r\n    const client = new Twitter(consumerKey, consumerSecret, access_token_key, access_token_secret);\r\n    const u = \"https://api.twitter.com/1.1/friends/list.json\";\r\n    const p = [new KV(\"screen_name\", \"TwitterJP\")];\r\n    const json = await client.get(u, p);\r\n    console.info(json);\r\n    // var cred = await client.get(\"account/verify_credentials2\");\r\n    // 記録情報がNGなら認証\r\n    // if (result.access_token == null) {\r\n    //   state = _STATE.REQUIRE;\r\n    //   client = new Twitter({\r\n    //     consumer_key: consumerKey,\r\n    //     consumer_secret: consumerSecret,\r\n    //   });\r\n    //   let tokenReponse = await client.getRequestToken(\"https://google.com\");\r\n    //   if (result.access_token == null) {\r\n    //     state = _STATE.ERROR;\r\n    //     error = \"認証に失敗しました。\";\r\n    //     return;\r\n    //   }\r\n    // }\r\n    // if (userToken == null || userSecret == null) {\r\n    //   //\r\n    // }\r\n    text.focus();\r\n});\r\n// WebView2 活性時\r\nwindow[\"OnActive\"] = () => {\r\n    text.focus();\r\n};\r\n</script>\n\n<style lang=\"scss\">textarea {\n  width: 100%;\n  height: 100%;\n}</style>\n\n<main>\n  {#if state == _STATE.ERROR}\n    <div>{error}</div>\n  {:else if state == _STATE.INIT}\n    初期化中\n  {:else if state == _STATE.REQUIRE}\n    <button on:change={handleClick}>認証</button>\n  {:else}\n    <textarea bind:this={text} on:change={handleClick} />\n  {/if}\n</main>\n"
  ],
  "names": [],
  "mappings": "AAiMmB,QAAQ,cAAC,CAAC,AAC3B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACd,CAAC"
}